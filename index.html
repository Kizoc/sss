<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>订阅解码重命名上传工具</title>
  <style>
    /* 简洁样式 */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: #fff;
      margin: 0; padding: 20px;
      min-height: 100vh;
      display: flex; flex-direction: column; align-items: center;
    }
    h2 {
      font-weight: 700; font-size: 2.2rem; text-align: center; margin-bottom: 10px;
      text-shadow: 2px 2px 8px rgba(0,0,0,0.4);
    }
    textarea, input, select, button {
      width: 100%;
      max-width: 800px;
      border-radius: 12px;
      border: none;
      padding: 12px 15px;
      font-size: 1rem;
      margin-bottom: 15px;
      box-sizing: border-box;
    }
    textarea {
      height: 260px;
      font-family: 'Consolas', monospace;
      background: #2b2b50;
      color: #e0e0e0;
      resize: vertical;
      box-shadow: 0 8px 15px rgba(0,0,0,0.2);
      transition: box-shadow 0.3s ease;
    }
    textarea:focus, input:focus {
      outline: none;
      box-shadow: 0 8px 25px #8a8aff;
      background: #36365a;
    }
    button {
      background: linear-gradient(45deg, #ff7e5f, #feb47b);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 15px rgba(255, 126, 95, 0.5);
      transition: all 0.3s ease;
      min-height: 45px;
    }
    button:hover {
      background: linear-gradient(45deg, #feb47b, #ff7e5f);
      box-shadow: 0 6px 25px rgba(254, 180, 123, 0.8);
      transform: translateY(-3px);
    }
    .button-row {
      display: flex;
      gap: 15px;
      max-width: 800px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .button-row button {
      flex: 1 1 120px;
    }
    #output {
      white-space: pre-wrap;
      background: rgba(255,255,255,0.1);
      max-width: 800px;
      padding: 15px 20px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      min-height: 180px;
      font-family: 'Consolas', monospace;
      user-select: text;
      color: #f0f0f0;
      overflow-wrap: break-word;
    }
    #status {
      max-width: 800px;
      text-align: center;
      margin-top: 10px;
      color: #ffc107;
      min-height: 24px;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <h2>订阅解码・重命名・上传工具</h2>

  <!-- 第一步：输入订阅链接或订阅内容 -->
  <label for="subInput">步骤 1：输入订阅链接 或 粘贴订阅内容</label>
  <input id="subInput" type="text" placeholder="请输入订阅链接，或粘贴节点订阅内容"/>

  <!-- 解码按钮 -->
  <div class="button-row">
    <button onclick="decodeWithWorker()">用 Worker 解码</button>
    <button onclick="decodeDirect()">本地直连解码</button>
  </div>

  <label for="decodedArea">解码结果（Base64 解码后）</label>
  <textarea id="decodedArea" placeholder="解码后的节点列表将显示在这里..." readonly></textarea>

  <!-- 第二步：重命名 -->
  <button onclick="renameNodes()" style="max-width: 800px; margin-bottom: 10px;">步骤 2：开始重命名（帅比｜高速｜国家）</button>

  <label for="renamedArea">重命名结果</label>
  <textarea id="renamedArea" placeholder="重命名后的节点列表将显示在这里..." readonly></textarea>

  <!-- 第三步：GitHub Token -->
  <label for="tokenInput">步骤 3：输入 GitHub Token（用于上传）</label>
  <input id="tokenInput" type="text" placeholder="请输入 GitHub Token"/>

  <!-- 上传按钮 -->
  <button onclick="uploadToGitHub()" style="max-width: 800px;">步骤 4：上传重命名结果到 GitHub（sss 仓库 index.html）</button>

  <div id="status"></div>

  <script>
    // 全世界国家列表（简化版）
    const allCountries = [
      "中国","香港","澳门","台湾","美国","英国","日本","新加坡","韩国","德国","法国","澳大利亚","俄罗斯","加拿大",
      "阿根廷","墨西哥","意大利","西班牙","瑞士","荷兰","瑞典","比利时","挪威","丹麦","芬兰","奥地利","爱尔兰",
      "葡萄牙","乌克兰","白俄罗斯","波兰","匈牙利","捷克","斯洛伐克","罗马尼亚","保加利亚","希腊","土耳其",
      "以色列","阿联酋","卡塔尔","沙特","伊朗","印度","巴基斯坦","越南","菲律宾","马来西亚","泰国","印尼",
      "柬埔寨","老挝","缅甸","孟加拉","哈萨克斯坦","乌兹别克斯坦","斯里兰卡","尼泊尔","南非","尼日利亚","埃及",
      "摩洛哥","阿尔及利亚","突尼斯","肯尼亚","坦桑尼亚","加纳","安哥拉","伊拉克","叙利亚","约旦","黎巴嫩",
      "也门","阿富汗","新西兰","文莱","蒙古","塞尔维亚","克罗地亚","斯洛文尼亚","波黑","北马其顿","爱沙尼亚",
      "拉脱维亚","立陶宛","冰岛","卢森堡","列支敦士登","马耳他","安道尔","圣马力诺","梵蒂冈","格鲁吉亚","亚美尼亚",
      "阿塞拜疆","摩尔多瓦","古巴","巴西","智利","哥伦比亚","秘鲁","厄瓜多尔","乌拉圭","巴拉圭","玻利维亚",
      "委内瑞拉","巴拿马","哥斯达黎加","洪都拉斯","尼加拉瓜","萨尔瓦多","多米尼加","牙买加","特立尼达和多巴哥",
      "南苏丹","苏丹","刚果","刚果（金）","乍得","利比亚","津巴布韦","赞比亚","博茨瓦纳","纳米比亚","马达加斯加",
      "毛里求斯","马尔代夫","斐济","汤加","帕劳","密克罗尼西亚","马绍尔群岛"
    ];

    // 解码（Worker版）
    async function decodeWithWorker() {
      const subUrl = document.getElementById('subInput').value.trim();
      const decodedArea = document.getElementById('decodedArea');
      const status = document.getElementById('status');
      if (!subUrl) {
        alert("请输入订阅链接或内容！");
        return;
      }
      status.textContent = "用 Worker 代理请求订阅...";
      try {
        // 你的 Worker 代理地址，这里示例，用你自己的改
        const workerProxy = 'https://proxy-worker.kizoc369.workers.dev/?url=';
        const res = await fetch(workerProxy + encodeURIComponent(subUrl));
        if (!res.ok) throw new Error('请求失败，状态码: ' + res.status);
        const rawText = await res.text();

        // 可能返回的是 Base64，尝试解码
        try {
          const decoded = atob(rawText.trim());
          decodedArea.value = decoded;
          status.textContent = "解码成功（Worker代理）";
        } catch {
          // 不是Base64直接显示
          decodedArea.value = rawText;
          status.textContent = "解码成功（Worker代理，非Base64内容）";
        }
      } catch (e) {
        status.textContent = "Worker解码失败: " + e.message;
      }
    }

    // 解码（本地直连）
    async function decodeDirect() {
      const subUrl = document.getElementById('subInput').value.trim();
      const decodedArea = document.getElementById('decodedArea');
      const status = document.getElementById('status');
      if (!subUrl) {
        alert("请输入订阅链接或内容！");
        return;
      }
      status.textContent = "本地直连请求订阅...";
      try {
        const res = await fetch(subUrl);
        if (!res.ok) throw new Error('请求失败，状态码: ' + res.status);
        const rawText = await res.text();

        try {
          const decoded = atob(rawText.trim());
          decodedArea.value = decoded;
          status.textContent = "解码成功（本地直连）";
        } catch {
          decodedArea.value = rawText;
          status.textContent = "解码成功（本地直连，非Base64内容）";
        }
      } catch (e) {
        status.textContent = "本地直连解码失败: " + e.message;
      }
    }

    // 提取国家信息
    function extractCountry(text) {
      for (const c of allCountries) {
        if (text.includes(c)) return c;
      }
      return null;
    }

    // 格式化备注
    function formatRemark(country, order) {
      if (country) return `帅比｜高速｜${country}`;
      else return `无法识别-${order}｜帅比｜高速`;
    }

    // 重命名节点
    function renameNodes() {
      const decodedArea = document.getElementById('decodedArea');
      const renamedArea = document.getElementById('renamedArea');
      const lines = decodedArea.value.trim().split('\n').filter(l => l.trim());
      let order = 1;

      const knownNodes = [];
      const unknownNodes = [];

      // 增加辅助函数，给节点加备注
      function addRemark(line, order, country) {
        const remark = formatRemark(country, order);
        if (line.includes('#')) {
          // 替换原备注
          return line.replace(/#.*$/, '#' + encodeURIComponent(remark));
        } else {
          return line + '#' + encodeURIComponent(remark);
        }
      }

      for (const line of lines) {
        let country = null;
        // vmess协议
        if (line.startsWith('vmess://')) {
          try {
            const base64 = line.slice(8);
            const jsonStr = atob(base64);
            const obj = JSON.parse(jsonStr);
            country = extractCountry(obj.ps || '');
            obj.ps = formatRemark(country, order);
            const newLine = 'vmess://' + btoa(JSON.stringify(obj));
            if (country) knownNodes.push(newLine);
            else unknownNodes.push({line: newLine, order: order});
          } catch {
            unknownNodes.push({line, order: order});
          }
        }
        // vless和trojan协议
        else if (line.startsWith('vless://') || line.startsWith('trojan://')) {
          try {
            const protoMatch = line.match(/^(\w+):\/\//);
            if (!protoMatch) throw '协议错误';
            const proto = protoMatch[1];
            const rest = line.slice(proto.length + 3);
            let mainPart = rest;
            let remark = '';
            if (rest.includes('#')) {
              const idx = rest.indexOf('#');
              mainPart = rest.slice(0, idx);
              remark = decodeURIComponent(rest.slice(idx + 1));
            }
            country = extractCountry(remark);
            const newRemark = formatRemark(country, order);
            const newLine = proto + '://' + mainPart + '#' + encodeURIComponent(newRemark);
            if (country) knownNodes.push(newLine);
            else unknownNodes.push({line: newLine, order: order});
          } catch {
            unknownNodes.push({line, order: order});
          }
        }
        // ss和ssr协议
        else if (line.startsWith('ss://') || line.startsWith('ssr://')) {
          try {
            const protoMatch = line.match(/^(\w+):\/\//);
            if (!protoMatch) throw '协议错误';
            const proto = protoMatch[1];
            const rest = line.slice(proto.length + 3);
            let mainPart = rest;
            let remark = '';
            if (rest.includes('#')) {
              const idx = rest.indexOf('#');
              mainPart = rest.slice(0, idx);
              remark = decodeURIComponent(rest.slice(idx + 1));
            }
            country = extractCountry(remark);
            const newRemark = formatRemark(country, order);
            const newLine = proto + '://' + mainPart + '#' + encodeURIComponent(newRemark);
            if (country) knownNodes.push(newLine);
            else unknownNodes.push({line: newLine, order: order});
          } catch {
            unknownNodes.push({line, order: order});
          }
        } else {
          unknownNodes.push({line: line + '#' + encodeURIComponent(formatRemark(null, order)), order: order});
        }
        order++;
      }

      // 拼接最终顺序：先已知国家，后无法识别
      const finalLines = knownNodes.concat(unknownNodes.map(item => item.line));
      renamedArea.value = finalLines.join('\n');
      document.getElementById('status').textContent = `重命名完成！共处理节点 ${lines.length} 条，未知国家 ${unknownNodes.length} 条`;
    }

    // 上传到GitHub sss仓库 index.html
    async function uploadToGitHub() {
      const token = document.getElementById('tokenInput').value.trim();
      const renamedArea = document.getElementById('renamedArea');
      const status = document.getElementById('status');
      if (!token) {
        alert("请输入 GitHub Token！");
        return;
      }
      if (!renamedArea.value.trim()) {
        alert("请先完成重命名，确保有内容！");
        return;
      }

      status.textContent = "正在上传到 GitHub 仓库 sss 的 index.html ...";

      const owner = await getGitHubUsername(token);
      if (!owner) {
        status.textContent = "获取用户名失败，Token 无效或网络异常。";
        return;
      }

      const repo = 'sss';
      const path = 'index.html';
      const content = btoa(unescape(encodeURIComponent(renamedArea.value))); // UTF-8 base64 encode

      // 先获取文件 sha，判断是否存在
      let sha = null;
      try {
        const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
          headers: {
            Authorization: `token ${token}`,
            Accept: 'application/vnd.github.v3+json'
          }
        });
        if (res.ok) {
          const data = await res.json();
          sha = data.sha;
        } else if (res.status !== 404) {
          status.textContent = `获取文件信息失败：${res.status}`;
          return;
        }
      } catch (e) {
        status.textContent = "请求异常：" + e.message;
        return;
      }

      // 准备提交体
      const body = {
        message: '自动上传重命名订阅节点',
        content: content,
        branch: 'main'
      };
      if (sha) body.sha = sha;

      // 上传PUT请求
      try {
        const putRes = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
          method: 'PUT',
          headers: {
            Authorization: `token ${token}`,
            'Content-Type': 'application/json',
            Accept: 'application/vnd.github.v3+json'
          },
          body: JSON.stringify(body)
        });
        if (putRes.ok) {
          status.textContent = "✅ 上传成功！文件路径： " + `https://${owner}.github.io/${repo}/${path}`;
          alert("上传成功！你可以访问:\n" + `https://${owner}.github.io/${repo}/${path}`);
        } else {
          const err = await putRes.json();
          status.textContent = "上传失败：" + (err.message || '未知错误');
        }
      } catch (e) {
        status.textContent = "上传异常：" + e.message;
      }
    }

    // 通过Token获取用户名
    async function getGitHubUsername(token) {
      try {
        const res = await fetch('https://api.github.com/user', {
          headers: {
            Authorization: `token ${token}`,
            Accept: 'application/vnd.github.v3+json'
          }
        });
        if (!res.ok) return null;
        const data = await res.json();
        return data.login;
      } catch {
        return null;
      }
